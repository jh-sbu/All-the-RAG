"""
Generated by GPT5-Thinking
"""

import re
from typing import List

_SENTENCE_END_RE = re.compile(
    r"""                # look for sentence-ish endings before whitespace or EOS
    (?<=\S)             # preceding non-space
    (?:[.!?]|…|[。！？])  # common end punctuation (western + CJK + ellipsis)
    ["'”’」】)]*         # optional closing quotes/brackets
    (?=\s|$)            # followed by whitespace or end of string
    """,
    re.VERBOSE,
)


def chunk_text(document: str, chunk_size: int = 1000, overlap: int = 200) -> List[str]:
    """
    Split `document` into overlapping chunks of about `chunk_size` characters.

    The splitter prefers to cut on sentence boundaries; if none are found
    within the window, it falls back to the last whitespace, and finally
    to a hard split at `chunk_size`.

    Args:
        document: The input text.
        chunk_size: Target maximum size of each chunk (characters).
        overlap: Number of characters to overlap between consecutive chunks.

    Returns:
        List[str]: Ordered list of text chunks.
    """
    if not document:
        return []

    if chunk_size <= 0:
        raise ValueError("chunk_size must be > 0")
    if overlap < 0:
        raise ValueError("overlap must be >= 0")

    # Ensure overlap < chunk_size to guarantee forward progress.
    if overlap >= chunk_size:
        overlap = max(0, chunk_size - 1)

    n = len(document)
    i = 0
    chunks: List[str] = []

    while i < n:
        # Tentative end of the window
        window_end = min(i + chunk_size, n)
        window = document[i:window_end]

        cut = None  # index in absolute coordinates where we end the chunk (exclusive)

        # 1) Prefer the last sentence boundary in the window
        last_sent_end = None
        for m in _SENTENCE_END_RE.finditer(window):
            last_sent_end = m.end()
        if last_sent_end is not None:
            cut = i + last_sent_end

        # If no sentence boundary, 2) try the last whitespace
        if cut is None:
            ws_pos = max(window.rfind(" "), window.rfind("\n"), window.rfind("\t"))
            if ws_pos != -1 and ws_pos > 0:
                cut = i + ws_pos

        # 3) If still nothing usable, hard cut at the window end
        if cut is None or cut <= i:
            cut = window_end

        # Extract the chunk (strip outer whitespace, preserve interior spacing)
        chunk = document[i:cut].strip()
        if chunk:
            chunks.append(chunk)

        if cut >= n:
            break

        # Compute next start with overlap; guarantee forward progress
        # even for tiny chunks by capping overlap to (chunk_length - 1).
        chunk_len = max(1, cut - i)
        eff_overlap = min(overlap, max(0, chunk_len - 1))
        i = cut - eff_overlap

    return chunks
